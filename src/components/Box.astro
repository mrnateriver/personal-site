---
import { getBoxStyleVars, type BoxProps } from './box-properties';

interface BaseBoxProps {
  style?: Record<string, string>;
  class?: string;
}

export type Props = (BaseBoxProps & { skipStyleVars: true }) | (BaseBoxProps & { skipStyleVars?: false } & BoxProps);

const { class: className, style: boxStyle, skipStyleVars = false } = Astro.props;

// There are quite a lot of vars, and they get injected into all children, so to save up space, inject them manually
// instead of using the `define:vars` prop.
const style = {
  ...boxStyle,
  ...(skipStyleVars ? {} : getBoxStyleVars(Astro.props as BoxProps)),
};
---

<i class:list={['box', className]} style={style}>
  <i class="box-sides-x"></i>
  <i class="box-sides-y"></i>
  <i class="box-sides-z"></i>
</i>

<style lang="scss">
  @keyframes cube-rotation {
    0% {
      transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg);
    }
    100% {
      transform: rotateX(180deg) rotateY(0deg) rotateZ(0deg);
    }
  }

  .box {
    will-change: transform;
    transform-origin: center center;
    animation: cube-rotation 3s forwards 2s cubic-bezier(0.68, -0.55, 0.27, 1.55); // FIXME: TEMP!
    display: block;

    width: var(--wx);
    height: var(--wy);
    transform-style: preserve-3d;
    overflow: visible;

    [class^='box-sides-']::before,
    [class^='box-sides-']::after {
      content: '';
      display: block;
      position: absolute;
      left: 0;
      top: 0;
    }

    &-sides {
      &-x,
      &-y,
      &-z {
        transform-style: preserve-3d;
        display: block;
      }

      &-y {
        &::before,
        &::after {
          transform-origin: center top;
          height: var(--wz);
          width: var(--wx);
        }

        &::before {
          transform: rotateX(-90deg) translateY(calc(var(--wz) / -2));
          background-image: linear-gradient(to bottom, var(--surface-top-color-dark), transparent),
            linear-gradient(to right, var(--surface-top-color-dark), transparent),
            linear-gradient(to bottom, var(--surface-top-color), var(--surface-top-color-light));
          background-size: 1px 100%, 100% 1px, auto;
          background-repeat: no-repeat;
        }

        &::after {
          transform: translateY(var(--wy)) rotateX(-90deg) translateY(calc(var(--wz) / -2));
          background-color: var(--surface-bottom-color-dark);
        }
      }

      &-z {
        &::before,
        &::after {
          height: var(--wy);
          width: var(--wx);
        }

        &::before {
          transform: translateZ(calc(var(--wz) / 2));
          background-image: linear-gradient(to bottom, var(--surface-front-color), var(--surface-front-color-dark));
        }

        &::after {
          transform: translateZ(calc(-1 * var(--wz) + var(--wz) / 2));
          background-color: var(--surface-back-color);
        }
      }

      &-x {
        &::before,
        &::after {
          height: var(--wy);
          width: var(--wz);
          background-size: 2px 100%, auto auto;
          background-repeat: no-repeat;
          transform-origin: left center;
        }

        &::before {
          transform: translateZ(calc(var(--wz) / 2)) rotateY(90deg);
          background-image: linear-gradient(to bottom, var(--surface-left-color-dark), transparent),
            linear-gradient(to bottom, var(--surface-left-color), var(--surface-left-color-medium));
        }

        &::after {
          transform: translateZ(calc(var(--wz) / 2)) translateX(var(--wx)) rotateY(90deg);
          background-image: linear-gradient(to bottom, var(--surface-right-color-dark), transparent),
            linear-gradient(to bottom, var(--surface-right-color), var(--surface-right-color-medium));
        }
      }
    }
  }
</style>
