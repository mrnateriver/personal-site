---
import type { Color } from '../colors';
import { readBmpImage, type BitmapImagePath, type ImagePixelFrames } from '../images';

import BoxGrid, { type Props as BoxGridProps } from './BoxGrid.astro';

interface BaseProps
  extends Pick<BoxGridProps, 'gapPx' | 'cellSizePx' | 'hideSurfaces' | 'animationFrameMs' | 'animationDelayMs'> {
  class?: string;
  cellsColor?: Color;
}

export type Props = BaseProps &
  (
    | {
        imagePath: BitmapImagePath;
      }
    | {
        framesImagesPaths: BitmapImagePath[];
      }
  );

const props = Astro.props;
const { class: className, cellsColor, hideSurfaces, animationFrameMs, animationDelayMs, gapPx, cellSizePx } = props;

let imagePixels: ImagePixelFrames[][];
if ('imagePath' in props) {
  imagePixels = (await readBmpImage(props.imagePath)).map((r) =>
    r.map((p) => [(p === 0xffffffff ? null : cellsColor) ?? p] as ImagePixelFrames),
  );
} else {
  const frames = await Promise.all(props.framesImagesPaths.map(readBmpImage));

  const [firstFrame, ...otherFrames] = frames;
  if (!otherFrames.every((f) => f.length === firstFrame.length && f[0].length === firstFrame[0].length)) {
    throw new Error('All frames must have the same dimensions');
  }

  imagePixels = firstFrame.map((row, y) =>
    row.map((_, x) => frames.map((f) => cellsColor ?? f[y][x]) as ImagePixelFrames),
  );
}
---

<BoxGrid
  class={className}
  rows={imagePixels}
  hideSurfaces={hideSurfaces}
  animationDelayMs={animationDelayMs}
  animationFrameMs={animationFrameMs}
  cellSizePx={cellSizePx}
  gapPx={gapPx}
/>
