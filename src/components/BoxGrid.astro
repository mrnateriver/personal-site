---
import { convertRGBAToHSLA, normalizeColor, type Color } from '../colors';
import type { ImagePixelFrames } from '../images';

import { getBoxStyleVars, type BoxProps } from './box-properties';
import Box, { type BaseBoxProps } from './Box.astro';

export interface Props extends Pick<BaseBoxProps, 'hideSurfaces'> {
  class?: string;
  /**
   * Gap between boxes in `px` unit.
   * @default 2
   */
  gapPx?: number;
  /**
   * Size of each box in `px` unit.
   * @default 24
   */
  cellSizePx?: number;
  /**
   * Which color should be treated as transparent.
   * The first frame is checked against this color, and if it's transparent, the whole pixel is skipped.
   * @default 0xffffffff
   */
  transparentColor?: Color;
  /**
   * @default 3000
   */
  animationFrameMs?: number;
  /**
   * @default 0
   */
  animationDelayMs?: number;
  rows: ImagePixelFrames[][]; // Pixel Rows -> Columns -> Frames+
}

const {
  gapPx = 2,
  cellSizePx = 24,
  transparentColor = 0xffffffff,
  rows,
  class: className,
  hideSurfaces,
  animationFrameMs = 3000,
  animationDelayMs = 0,
} = Astro.props;

let rowLength = -1;
for (const row of rows) {
  if (rowLength >= 0 && row.length !== rowLength) {
    throw new Error('All rows must have the same length');
  }
  rowLength = row.length;
}

const rowsWithVisibleCells = rows
  .map((row) => row.map((c, j) => [c, j] as const).filter(([c]) => c[0] !== transparentColor))
  .filter((row) => row.length > 0);

const rowsByColors = new Map<Color, Map<number, number[]>>(); // Color -> Row Index -> Column Index[]
const cellsFrames = new Map<number, { count: number; styles: Record<string, unknown> }>(); // Row Index * Row Length + Column Index -> Frame Index[]

rowsWithVisibleCells.forEach((row, i) => {
  for (const entry of row) {
    const [colors, column] = entry;
    const color = colors[0];

    if (colors.length > 1) {
      const cellIndex = i * rowLength + column;
      cellsFrames.set(cellIndex, {
        count: colors.length,
        styles: Object.fromEntries(
          colors
            .slice(1)
            .map((color, frameIndex) => {
              const normalized = normalizeColor(color);
              if (!normalized) {
                throw new Error(`Invalid color: ${color}`);
              }
              const hsla = convertRGBAToHSLA(normalized);
              const hsColor = `${hsla.h} ${hsla.s}%`;
              return [
                [`--f-${frameIndex + 2}`, hsColor],
                [`--f-${frameIndex + 2}-l`, `${hsla.l}%`],
              ];
            })
            .flat(),
        ),
      });
    }

    if (!rowsByColors.has(color)) {
      rowsByColors.set(color, new Map([[i, []]]));
    }
    if (!rowsByColors.get(color)?.has(i)) {
      rowsByColors.get(color)?.set(i, []);
    }

    rowsByColors.get(color)?.get(i)?.push(column);
  }
});

const style = {
  '--gap': `${gapPx}px`,
  '--cell-size': `${cellSizePx}px`,
  '--rows-count': rows.length,
  '--columns-count': rows[0]?.length ?? 0,
  '--animation-frame-ms': `${animationFrameMs}ms`,
  '--animation-delay-ms': `${animationDelayMs}ms`,
  '--total-rows': rows.length,
} as const;

const baseSectionProps: BoxProps = {
  surfaceColor: 0x00000000,
  wx: cellSizePx,
  wy: cellSizePx,
  wz: cellSizePx,
};
---

<div class:list={['grid', className]} style={style}>
  {
    Array.from(rowsByColors.entries()).map(([surfaceColor, rows]) => (
      <div class="grid-section" style={getBoxStyleVars({ ...baseSectionProps, surfaceColor })}>
        {Array.from(rows.entries()).map(([rowIndex, cells]) => (
          <div class="grid-section-row" style={{ '--ri': rowIndex, top: `${rowIndex * (cellSizePx + gapPx)}px` }}>
            {cells.map((columnIndex) => {
              const frames = cellsFrames.get(rowIndex * rowLength + columnIndex);
              return (
                <Box
                  class={`grid-section-row-cell ${frames?.count ? `frame-animate-${frames.count}` : ''}`}
                  style={{ left: `${columnIndex * (cellSizePx + gapPx)}px`, ...frames?.styles }}
                  skipStyleVars={true}
                  hideSurfaces={hideSurfaces}
                />
              );
            })}
          </div>
        ))}
      </div>
    ))
  }
</div>

<style lang="scss" is:global>
  @use 'sass:math';
  @use 'sass:list';

  $max-animation-frames: 10;
  $surface-color-var-names: [[ 't', 'f'], [ 'b', 'bk']];

  @mixin vars($frameIndex) {
    $surface-var-name-0: list.nth(list.nth($surface-color-var-names, $frameIndex % 2 + 1 /* indices are 1-based */), 1);
    $surface-var-name-1: list.nth(list.nth($surface-color-var-names, $frameIndex % 2 + 1 /* indices are 1-based */), 2);

    --s#{$surface-var-name-0}: var(--f-#{$frameIndex + 1});
    --s#{$surface-var-name-1}: var(--f-#{$frameIndex + 1});
    --s#{$surface-var-name-0}-l: var(--f-#{$frameIndex + 1}-l);
    --s#{$surface-var-name-1}-l: var(--f-#{$frameIndex + 1}-l);
  }

  @mixin frame($frameIndex, $rotation) {
    @include vars($frameIndex);
    transform: rotateX($rotation * 180deg);
  }

  @for $frameCount from 1 to $max-animation-frames {
    @keyframes frame-color-animation-#{$frameCount + 1} {
      $increment: math.div(100%, $frameCount * 2 - 1);

      @for $stage from 0 to $frameCount {
        #{$stage * 2 * $increment} {
          @if $stage > 0 {
            @include vars($stage);
          }
          @include frame($stage + 1, $stage);
        }
        #{($stage * 2 + 1) * $increment} {
          @include frame($stage + 1, $stage + 1);
        }
      }
    }
  }

  .box.frame-animate {
    @for $i from 1 through $max-animation-frames {
      &-#{$i + 1} {
        animation: frame-color-animation-#{$i +
          1}
          calc(var(--animation-frame-ms) * $i)
          forwards
          var(--overshoot-function);
        animation-delay: var(--animation-delay-ms);
      }
    }
  }
</style>

<style lang="scss">
  .grid {
    height: calc(var(--rows-count) * var(--cell-size) + (var(--rows-count) - 1) * var(--gap));
    width: calc(var(--columns-count) * var(--cell-size) + (var(--columns-count) - 1) * var(--gap));
    transform-style: preserve-3d;
    position: relative;

    &-section {
      transform-style: preserve-3d;
      position: absolute;
      left: 0;
      top: 0;

      &-row {
        height: var(--cell-size);
        transform-style: preserve-3d;
        position: absolute;

        &-cell {
          position: absolute;
        }
      }
    }
  }
</style>
