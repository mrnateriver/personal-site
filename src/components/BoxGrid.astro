---
import { normalizeColor, type Color } from '../colors';
import type { ImagePixelFrames } from '../images';

import { getBoxStyleVars, type BoxProps } from './box-properties';
import Box, { type BaseBoxProps } from './Box.astro';

export interface Props extends Pick<BaseBoxProps, 'hideSurfaces' | 'hideGradient'> {
  class?: string;
  /**
   * Gap between boxes in `px` unit.
   * @default 2
   */
  gapPx?: number;
  /**
   * Size of each box in `px` unit.
   * @default 24
   */
  cellSizePx?: number;
  /**
   * Which color should be treated as transparent.
   * The first frame is checked against this color, and if it's transparent, the whole pixel is skipped.
   * @default 0xffffffff
   */
  transparentColor?: Color;
  /**
   * @default 3000
   */
  animationFrameMs?: number;
  /**
   * @default 0
   */
  animationDelayMs?: number;
  rows: ImagePixelFrames[][]; // Pixel Rows -> Columns -> Frames+
}

const {
  gapPx = 2,
  cellSizePx = 24,
  transparentColor = 0xffffffff,
  rows,
  class: className,
  hideSurfaces,
  hideGradient,
  animationFrameMs = 3000,
  animationDelayMs = 0,
} = Astro.props;

let rowLength = -1;
for (const row of rows) {
  if (rowLength >= 0 && row.length !== rowLength) {
    throw new Error('All rows must have the same length');
  }
  rowLength = row.length;
}

const normalizedTransparentColor = normalizeColor(transparentColor);

const rowsWithVisibleCells = rows
  .map((row) =>
    row
      .map((color, rowIndex) => [color, rowIndex] as const)
      .filter(([c]) => normalizeColor(c[0])! !== normalizedTransparentColor),
  )
  .filter((row) => row.length > 0);

const rowsByColors = new Map<Color, Map<number, number[]>>(); // Color -> Row Index -> Column Index[]
const cellsHiddenSurfaces = new Map<number, Partial<BaseBoxProps['hideSurfaces']>>(); // Cell Index -> Hidden Surfaces, if any
const cellsFrames = new Map<number, { count: number; styles: Record<string, unknown> }>(); // Row Index * Row Length + Column Index -> Frame Index[]

rowsWithVisibleCells.forEach((row, i) => {
  row.forEach((pixel, pixelRowIndex) => {
    const [colors, columnIndex] = pixel;
    const color = colors[0];

    const cellIndex = i * rowLength + columnIndex;

    if (colors.length > 1) {
      cellsFrames.set(cellIndex, {
        count: colors.length,
        styles: Object.fromEntries(
          colors
            .slice(1)
            .map((color, frameIndex) => {
              const res = [];
              const normalized = normalizeColor(color);
              if (normalized) {
                res.push([`--f${frameIndex + 2}`, normalizeColor(color)]);
              }
              return res;
            })
            .flat(),
        ),
      });
    }

    if (!rowsByColors.has(color)) {
      rowsByColors.set(color, new Map([[i, []]]));
    }
    if (!rowsByColors.get(color)?.has(i)) {
      rowsByColors.get(color)?.set(i, []);
    }

    rowsByColors.get(color)?.get(i)?.push(columnIndex);

    if (gapPx === 0) {
      if (pixelRowIndex > 0) {
        const prevPixel = row[pixelRowIndex - 1];
        if (prevPixel[1] === columnIndex - 1) {
          cellsHiddenSurfaces.set(cellIndex, { ...cellsHiddenSurfaces.get(cellIndex), left: true });
        }
      }

      if (pixelRowIndex < row.length - 1) {
        const nextPixel = row[pixelRowIndex + 1];
        if (nextPixel[1] === columnIndex + 1) {
          cellsHiddenSurfaces.set(cellIndex, { ...cellsHiddenSurfaces.get(cellIndex), right: true });
        }
      }
    }
  });
});

const style = {
  '--gap': `${gapPx}px`,
  '--cell-size': `${cellSizePx}px`,
  '--rows-count': rowsWithVisibleCells.length,
  '--columns-count': rowLength,
  '--animation-frame-ms': `${animationFrameMs}ms`,
  '--animation-delay-ms': `${animationDelayMs}ms`,
} as const;

const baseSectionProps: BoxProps = {
  surfaceColor: 0x00000000,
  size: cellSizePx,
};
---

<div class:list={['grid', className]} style={style}>
  {
    Array.from(rowsByColors.entries()).map(([surfaceColor, rows]) => (
      <div class="grid-section" style={getBoxStyleVars({ ...baseSectionProps, surfaceColor })}>
        {Array.from(rows.entries()).map(([rowIndex, cells]) => (
          <div class="grid-section-row" style={{ '--ri': rowIndex, top: `${rowIndex * (cellSizePx + gapPx)}px` }}>
            {cells.map((columnIndex) => {
              const cellIndex = rowIndex * rowLength + columnIndex;
              const frames = cellsFrames.get(cellIndex);
              return (
                <Box
                  class={`grid-section-row-cell ${frames?.count ? `frame-animate-${frames.count}` : ''}`}
                  style={{ left: `${columnIndex * (cellSizePx + gapPx)}px`, ...frames?.styles }}
                  hideSurfaces={{ ...hideSurfaces, ...cellsHiddenSurfaces.get(cellIndex) }}
                  hideGradient={hideGradient}
                  skipStyleVars={true}
                />
              );
            })}
          </div>
        ))}
      </div>
    ))
  }
</div>

<style lang="scss" is:global>
  @use 'sass:math';
  @use 'sass:list';

  $max-animation-frames: 10;
  $surface-color-var-names: [[ 't', 'f'], [ 'b', 'bk']];

  @mixin vars($frameIndex) {
    $surface-var-name-0: list.nth(list.nth($surface-color-var-names, $frameIndex % 2 + 1 /* indices are 1-based */), 1);
    $surface-var-name-1: list.nth(list.nth($surface-color-var-names, $frameIndex % 2 + 1 /* indices are 1-based */), 2);

    --s#{$surface-var-name-0}: var(--f#{$frameIndex + 1});
    --s#{$surface-var-name-1}: var(--f#{$frameIndex + 1});
  }

  @mixin frame($frameIndex, $rotation) {
    @include vars($frameIndex);
    transform: rotateX($rotation * 180deg);
  }

  @for $frameCount from 1 to $max-animation-frames {
    @keyframes frame-color-animation-#{$frameCount + 1} {
      $increment: math.div(100%, $frameCount * 2 - 1);

      @for $stage from 0 to $frameCount {
        #{$stage * 2 * $increment} {
          @if $stage > 0 {
            @include vars($stage);
          }
          @include frame($stage + 1, $stage);
        }
        #{($stage * 2 + 1) * $increment} {
          @include frame($stage + 1, $stage + 1);
        }
      }
    }
  }

  .grid-section-row-cell.frame-animate {
    @for $i from 1 through $max-animation-frames {
      &-#{$i + 1} {
        animation: frame-color-animation-#{$i +
          1}
          calc(var(--animation-frame-ms) * $i)
          forwards
          cubic-bezier(0.68, -0.55, 0.27, 1.55); // TODO: single curve for all anims
        animation-delay: var(--animation-delay-ms);
      }
    }
  }
</style>

<style lang="scss">
  .grid {
    height: calc(var(--rows-count) * var(--cell-size) + (var(--rows-count) - 1) * var(--gap));
    width: calc(var(--columns-count) * var(--cell-size) + (var(--columns-count) - 1) * var(--gap));
    transform-style: preserve-3d;
    position: relative;

    &-section {
      transform-style: preserve-3d;
      position: absolute;
      left: 0;
      top: 0;

      &-row {
        height: var(--cell-size);
        transform-style: preserve-3d;
        position: absolute;

        &-cell {
          position: absolute;
        }
      }
    }
  }
</style>
