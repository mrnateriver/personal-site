---
import type { GetStaticPathsOptions, Page } from 'astro';
import { type CollectionEntry, getCollection, render } from 'astro:content';

import BlogLayout from '../../components/BlogLayout.astro';
import BlogPostList from '../../components/BlogPostList.astro';
import Win98Tree from '../../components/Win98Tree.astro';
import Win98Window from '../../components/Win98Window.astro';
import { kebabCase } from '../../utils';

type Mode = 'post' | 'pagination' | 'tag';

export interface Props {
  mode?: Mode;
  tag?: string;
  page?: Page<CollectionEntry<'blog'>>;
  post?: CollectionEntry<'blog'>;
  pageUrlPrefix?: string;
}

export async function getStaticPaths({ paginate }: GetStaticPathsOptions) {
  const pageSize = 5;

  const posts = (await getCollection('blog')).sort((a, b) => b.data.date.valueOf() - a.data.date.valueOf());
  const tags = Array.from(new Set(posts.flatMap((p) => p.data.tags ?? [])));

  let paths: Array<{
    params: { page: string | undefined };
    props: Props;
  }> = paginate(posts, {
    pageSize,
    props: { mode: 'pagination' as Mode, pageUrlPrefix: '/blog' },
  }).map((page) => ({
    ...page,
    params: page.params.page ? { page: page.params.page as string | undefined } : { page: undefined },
  }));

  paths = paths.concat(
    tags
      .map((tag) => {
        const kebabTag = kebabCase(tag);
        return paginate(
          posts.filter((p) => p.data.tags?.includes(tag)),
          {
            pageSize,
            props: { mode: 'tag' as Mode, tag, pageUrlPrefix: `/blog/${kebabTag}` },
          },
        ).map((page) => ({
          ...page,
          params: page.params.page ? { page: `${kebabTag}/${page.params.page}` } : { page: kebabTag },
        }));
      })
      .flat(),
  );

  paths = paths.concat(
    posts.map((post) => ({
      params: { page: post.id },
      props: { mode: 'post', post },
    })),
  );

  return paths;
}

const { mode, page, post, tag, pageUrlPrefix } = Astro.props;

const pageTitle = mode === 'post' ? post?.data.title : mode === 'tag' ? `${tag} Blog` : 'Blog';
const heading = mode === 'tag' ? `${tag} Posts` : undefined;

const renderedPost = post ? await render(post) : null;

const postNavigationNodes = [
  { text: post?.data.title ?? '', slug: 'heading-start' },
  ...(renderedPost?.headings ?? []),
].map((heading) => ({
  label: heading.text,
  href: `#${heading.slug}`,
}));

const PostContent = renderedPost?.Content ?? null!;
---

{
  page && (
    <BlogPostList
      pageTitle={pageTitle}
      heading={heading}
      posts={page.data}
      totalPages={page.lastPage}
      currentPage={page.currentPage}
      firstPageHref={pageUrlPrefix}
      pageHrefTemplate={`${pageUrlPrefix}/[page]`}
    />
  )
}

{
  post && (
    <BlogLayout title={post.data.title} description={post.data.oneliner} narrow>
      <main class="blog-content">
        <header class="blog-post-header">
          <h1 id="heading-start" class="blog-post-header-title">
            {post.data.title}
          </h1>
          <p class="blog-post-header-date">
            Published on{' '}
            {post.data.date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}
          </p>
        </header>
        <PostContent />
      </main>
      <Win98Window class="blog-post-navigation window-draggable" as="aside" caption="Contents" canvasBackground>
        <Win98Tree nodes={postNavigationNodes} />
      </Win98Window>
    </BlogLayout>
  )
}

<style lang="scss">
  .blog-post {
    display: flex;
    align-items: flex-start;

    &-header {
      margin: calc(1.5 * var(--padding-xlg)) 0;

      &-title {
        line-height: 1;
        margin: 0;
      }

      &-date {
        color: var(--color-text-tertiary);
        text-indent: 0 !important;
        margin: 0;
      }
    }

    &-navigation {
      width: 200px;
      position: fixed;
      left: calc(50% - var(--max-layout-blog-width) / 2 - 200px - var(--padding-lg));
      top: var(--padding-lg);
    }
  }
  .blog-content {
    margin-bottom: calc(10 * var(--padding-xlg));
  }
</style>
